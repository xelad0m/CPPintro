#include <iostream>
using namespace std;

// с сохранением адреса возврата взламываемой функции и возврата его на место
// (на практике обычно доступа к исходному коду не, поэтому это просто пример)
// Вектор атаки - проверка выхода за границы массива.

int foo(){
    int * m[1];
    cout << "Hello!" << endl;
    m[3] = m[4];            // сохраненный адрес возврата из bar() возвращаем на место
    return 2;
}

int bar(){
    int * m[1];             // массив размера 1
    m[4] = m[3];            // свой адрес возврата сохраним чуть подальше в стеке
    m[3] = (int *) &foo;    // а на его место пишем адрес функции foo()
    return 1;               // после выполнения foo() никаких следов от нее не осталов, bar() завершается как положено
}

int  main( ){
    bar();                  // при выходе из bar() вызовется foo(), при выходе из которой, как-бы завершится bar()
                            // Hello!
                            // и даже без ошибки сегментирования и никаких следов посторонних действий...
    return  0;
}