#include <iostream>   
using namespace std;                

// указатель на место в памяти (это такое число, которое сопоставляется месту в памяти, абстракция)
// <тип данных указателя> *<имя указателя>;

int main() 
{   
    int a;
    a = 0;
    a = 1;
    a = 256;

    // int *ptr;           // указатель на какой-нибудь int 
    // ptr = &a;           // присвоить указателю адрес в памяти, где лежит переменная a
    int *ptr = &a;      // или присвоить при объявлении
    *ptr = 2;           // записать по адресу указателя значение 2
    cout << a << endl;
    
    // указатель - это переменная (4 байта в 32разрядной ОС, 8 байт в 64битной ОС), в которой хранится адрес памяти, с которой работает этот указатель
    // тип данных при объявлении задает сколько байт памяти охватывает указатель

    char *ptr1;         // 1 байт
    short* ptr2;        // 2 байта
    int* ptr3;          // 4 байта
    double* ptr4;       // 8 байт

    int arr[] = {1, 2, 3, 4};

    int *p = arr;       // имя массива в С++ и есть указатель, & не обязательно

    cout << *p << endl;
    p++;                // увеличивается на размер int (4 байта), поэтому переходит ровно на следующий элемент
    cout << *p << endl;
    p++;
    cout << *p << endl;
    p++;
    cout << *p << endl;

    // приведение типов указателей 
    int x = 10;
    int *p1 = &x;
    char* p2;
    // p2 = p1;            // error: cannot convert ‘int*’ to ‘char*’ in assignment
    p2 = (char*)p1;     // позволит побайтно смотреть содержимое x

    for (int i = 0; i < sizeof(int); i++)
        // cout << (int)(*p2++) << " ";    // значение 10 в первой ячейке
        cout << (int)p2[i] << " ";    // лучше использовать синтаксис массива, т.к. p2 не будет сдвигаться
    cout << endl;
    
    // адресная арифметика   
    // p1 = p2; // если один тип
    // p1 = (char*)p2; //если разный тип
    // p1 += 5; // увеличение на 5 единиц информации
    // p1 -= 5; // уменьшение на 5 единиц информации
    // p1++; ++p1;
    // p1--; --p2;

    return 0;
}