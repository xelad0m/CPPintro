/*Реализуйте функцию копирования элементов copy_n из массива источника типа U* в целевой массив 
типа T*, где T и U произвольные типы, для которых определено преобразование из U в T. На вход 
функция принимает два указателя и количество элементов, которые необходимо скопировать.

Пример вызова функции copy_n:

int ints[] = {1, 2, 3, 4};
double doubles[4] = {};
copy_n(doubles, ints, 4); // теперь в массиве doubles содержатся элементы 1.0, 2.0, 3.0 и 4.0*/

// Параметры функции copy_n идут в следующем
// порядке:
//   1. целевой массив
//   2. массив источник
//   3. количество элементов, которые нужно
//      скопировать
//
// Вам нужно реализовать только функцию copy_n,
// чтобы ее можно было вызвать так, как показано
// в примере.

#include <cstddef>
#include <iostream>
using namespace std;

template <typename T, typename U>
void copy_n(T* dst, U* src, size_t n)
{
    for (int i=0; i < n; ++i)

        // решение не корректное, к деструктору типа доступа нет, а он нужен, чтобы удалять такое
        // new (dst + i) T(*(src+i));  // placement new (у нас указатель на уже выделенную память)
                                       // пишем туда новый T инициированный К.копирования от U (считаем, что К.копир. T не explicit)
        
        // корретные решения
        // *(dst + i) = T(*(src+i));   // Оп.присваивания T, К.копирования T (не explicit, не private)
        *(dst + i) = (T) *(src+i);     // К.преобразования в роли которого К.копирования
}
/*По умолчанию язык C++ обрабатывает любой конструктор, как оператор неявного преобразования. 
Неявное преобразование работает для всех видов инициализации (прямой, uniform и копирующей).
Конструкторы, которые используются в неявных преобразованиях, называются конструкторами преобразования 
(или «конструкторами конвертации»). До C++11 конструкторами преобразования могли быть конструкторы 
только с одним параметром. Однако в C++11 это ограничение было снято (наряду с добавлением 
uniform-инициализации), и конструкторы, имеющие несколько параметров, также уже могут быть 
конструкторами преобразования.*/

int main()
{
    int n = 4;
    int ints[] = {1, 2, 3, 4};      // указатель int*
    double doubles[n] = {};         // указатель double*
    copy_n(doubles, ints, n);

    for (int i=0; i < n; ++i)
        cout << *(doubles + i) << " ";
    cout << endl;
    return 0;
}