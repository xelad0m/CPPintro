// В этой и последующих задачах мы создадим свой простой аналог стандартного класса string для удобной работы со строками.

// Начнем мы с написания конструктора. В этой задаче вам требуется реализовать конструктор, который принимает на вход 
// C-style строку, вычисляет ее размер (без учета завершающего 0 символа) и сохраняет его в поле size, кроме того, 
// конструктор должен аллоцировать память достаточную для хранения копии переданной строки (вместе с завершающим 0 символом), 
// копирует переданную строку в выделенную память и сохраняет указатель на начало этой области памяти в поле str. 
// Т.е. в результате работы конструктора в поле str должен оказаться указатель на C-строку c копией исходной строки, 
// а в поле size — длина строки без учета завершающего нулевого символа. 

// Конструкторов у структуры может быть несколько. Для строки может оказаться полезным заполняющий конструктор (например, 
// чтобы создать строку пробелов). Заполняющий конструктор принимает число и символ, и создает строку с заданным количеством 
// повторений переданного символа. Условия налагаемые на реализацию конструктора те же самые (в поле size размер без учета 
// завершающего 0 символа, в поле str C-style строка, т.е. с завершающим 0 символом). Кроме конструктора в этой задаче вам 
// нужно также реализовать и деструктор, который освободит выделенную память. 

// Ваша задача реализовать метод append.
// При выполнении задания будьте аккуратны при работе с памятью — при вызове метода не должно возникать утечек памяти. 
// Кроме того, не забудьте, что size хранит размер без учета завершающего 0 символа. 

#include <iostream>
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String {
    /* Реализуйте этот конструктор */
	String(const char *str = "")
    {
        size = strlen(str);                         // можно без this
        char *new_str = new char [size + 1];        // указатель на строку длины size + 1
        strcpy(new_str, str);                       // вместо цикла, копирует \0 тоже
        this->str = new_str;                        // нельзя без this (указатель)
    }

    /* Реализуйте еще уот этот конструктор */
	String(size_t n, char c)
    {
        size = n;                   
        char *new_str = new char [size + 1];        
        for (size_t i = 0; i < size; ++i)
            *(new_str + i) = c;

        new_str[size] = '\0';
        this->str = new_str;
    }

    /* и уот деструктор */
	~String()
    {
        delete [] str;
    }

    /* Реализуйте этот метод. */
	void append(String &other)
    {   
        size_t _size = size;                        // свой исходный размер без \0
        size = size + other.size;                   // новый размер без \0
        char *new_str = new char [size + 1];        // +1 для \0

        strcpy(new_str, this->str);
        strcpy(new_str + _size, other.str);         // условный -1 для \0

        new_str[size] = '\0';                       // в тестах size + 1 дает ошибку (тут тоже должен по идее)

        delete [] this->str;                        // освободить занимаемую память
        this->str = new_str;                        // записать новую строку
    }

	size_t size;
	char *str;
};

int main()
{
    // 1
    const char * cstr = "C-style string";
    String str(cstr);
    std::cout << str.str << std::endl;

    // 2
    String str_(10, 'f');
    std::cout << str_.str << std::endl;

    // 3
    String s1("Hello,");
    String s2(" world!");

    s1.append(s2);                      // теперь s1 хранит "Hello, world!"
    std::cout << s1.str << std::endl;

    String s("Hello");
    s.append(s);                        // теперь s хранит "HelloHello"
    std::cout << s.str << std::endl;
}