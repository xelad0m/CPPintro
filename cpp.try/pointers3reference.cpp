#include <iostream>   
using namespace std;                

// Указатели (pointer) и ссылки (reference) — это два синтаксически разных способа в C++ выразить понятие адреса
// В языке С ссылок нет, только указатели.

// Есть операторы: & и *. 
// От любой переменной можно взять адрес при помощи операции взятия адреса "&". Эта операция возвращает указатель. Эквивалетная функция addressof()
// Указатель можно разыменовать при помощи операции разыменовывания "*". Это операция возвращает тот объект, на который указывает указатель.

// Особенности:
// нельзя получить адрес ссылки используя оператор адреса С++
// нельзя присвоить ссылке указатель
// нельзя использовать адресную арифметику со ссылками
// => Нельзя объявить массив ссылок.
// => У ссылки нет адреса.
// => Указатель может иметь «невалидное» значение с которым его можно сравнить перед использованием.
// ссылка - неизменяемый указатель?

// ИНТЕРЕСНО:
// Выражения, которым можно присваивать, называются lvalue в C, C++ и многих других языках. Остальные выражения называются rvalue.
// &*EXPR эквивалентно EXPR, всегда, когда имеет смысл (т. е. всегда, когда EXPR — указатель)
// *&EXPR тоже эквивалентно EXPR всегда, когда имеет смысл (т. е. когда EXPR — ссылка).
// Запись a[b] всегда эквивалентна *(a + b) - указатель на 0й элемент плюс смещение, или разыменование объекта по смещенной ссылке на a
// Запись &x + 1 это указатель на место сразу после объекта x.
// «Указатель на массив» 
// int (*a)[2]; // Это указатель на массив. Самый настоящий. Он имеет тип int (*TYPE)[2]
// int b[2];
// int *c = b; // Это не указатель на массив. Это просто указатель. Указатель на первый элемент некоего массива

// The value representation of pointer types is implementation-defined
// A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined
// Cтандарт позволяет при адресной арифметике выходить за пределы массива только на 1 элемент (но не разыменовывать его!). Далее одного элемента — UB. Нужно для итераторов.

void swap(int &a, int &b) {     // меняет значения по ссылкам, на месте, без return (int& a или int &a не имеет значения)
    int temp = a;
    a = b;
    b = temp;
}

int main() 
{   
    int x = 10;
    int *y = &x;    // От любой переменной можно взять адрес при помощи операции взятия адреса "&". Эта операция возвращает указатель
    int z = *y;     // Указатель можно разыменовать при помощи операции разыменовывания "*". Это операция возвращает тот объект, на который указывает указатель

    int x1 = 10;
    int &y1 = x1;     // Если слева от знака присваивания стоит ссылка, то нет никакого способа понять, хотим мы присвоить самой ссылке или объекту, на который она ссылается. 
    int z1 = y1;      // Поэтому такое присваивание всегда присваивает объекту, а не ссылке.

    cout << x << " " << *y << " " << z << endl
         << x1 << " " << y1 << " " << z1 << endl;

    int var;
    int &var2 = var;    // ссылка на var (присваивается только 1 раз, иммутабельность)
    // &var2 = b;       // error
    // var2 = &y;
    cout << &var2 << endl;

    int arg1 = 10, arg2 = 2;
    swap(arg1, arg2);
    cout << arg1 << " " << arg2 << endl;
    cout << arg1 << " " << &arg1 << endl;
    
    return 0;
}