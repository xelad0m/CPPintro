// Задание повышенной сложности.
// Определен следующий класс (он также приведен в комментарии в шаблоне кода):

// struct Cls {
//     Cls(char c, double d, int i);
// private:
//     char c;
//     double d;
//     int i;
// };

// Как видно, все поля этого класса закрытые, ваша задача реализовать несколько функций, которые дают полный доступ к этим полям (см. шаблон кода), 
// несмотря на то, что они закрытые.

// Внимание: предполагаемое решение этого задания существенно опирается на Undefined Behaviour и является исключительно учебным, 
// но полезно для лучшего понимания того, как работают модификаторы доступа. Решение было проверено на различных компиляторах (g++/clang++/icc/msvc), 
// но мы настоятельно не рекомендуем использовать подобные трюки в боевом коде.
#include <iostream>
using namespace std;

// #pragma pack(push,1)                    // отключение выравнивания, упакует подряд
struct Cls {
    Cls(char c, double d, int i)        // в примере конструктор только объявлен
        : c(c), d(d), i(i)              // добавим список инициализации, чтоб хоть как-то потестировать
    {}                                  // пустое определение (методы все равно отдельно и не вляют на упаковку данных в структуре)
private:
    char c;                             // 0-й байт (+7 пустых)
    double d;                           // 8-й байт (+0 пустых)
    int i;                              // 16-й байт (+4 пустых)
};
// #pragma pack(pop)                       // возвращение выравнивания

// преобразования типов в стиле С (арифметика указателей)
// Эта функция должна предоставить доступ к полю c объекта cls.
char &get_c(Cls &cls) 
{   
    char * c = (char *) &cls;       // преобразовать ссылку на структуру Cls в указатель на char
    return *c;                      // первый готов
}

// Эта функция должна предоставить доступ к полю d объекта cls.
double &get_d(Cls &cls)                 
{
    char * c = (char *) &cls;           // преобразовать ссылку на структуру Cls в указатель на char
    double * d = (double *) (c + 8);    // сдвинуть указатель на char на 8 байт (выравнивание по максимальному размеру в структуре?)
                                        // преобразовать к указателю на тип double 
    return *d;
}

// Эта функция должна предоставить доступ к полю i объекта cls.
int &get_i(Cls &cls) 
{
    char * c = (char *) &cls;           // преобразовать ссылку на структуру Cls в указатель на char
    double * d = (double *) (c + 8);    // сдвинуть указатель на char на 8 байт (выравнивание по максимальному размеру в структуре?)
                                        // преобразовать к указателю на тип double 
    int * i = (int *) (d + 1);          // сдвинуть указатель на double на 1, там будет лежать int, преобразовать в (int *)
    return *i;
}




// класс-близнец с публичными полями и приведение типов в стиле С++:
// reinterpret_cast<dataType>( value );

struct Cls_ {
    char c;                             
    double d;
    int i;
};

char &get_c_(Cls &cls) 
{   
    Cls_ * cls_ = reinterpret_cast<Cls_ *>(&cls);   // привести ссылку на cls к типу указателя на Cls_
    return cls_->c;                                 // доступк к полям по указателю через ->
}

double &get_d_(Cls &cls) 
{   
    Cls_ * cls_ = reinterpret_cast<Cls_ *>(&cls);   // привести ссылку на cls к типу указателя на Cls_
    return cls_->d;                                 // доступк к полям по указателю через ->
}

int &get_i_(Cls &cls) 
{   
    Cls_ * cls_ = reinterpret_cast<Cls_ *>(&cls);   // привести ссылку на cls к типу указателя на Cls_
    return cls_->i;                                 // доступк к полям по указателю через ->
}



int main() 
{   
    Cls cls ('h', 3.14, 42);
    
    /* через арифметику и приведение указателей (C-стиль) */
    cout << "C-style:" << endl;
    // чтение
    cout << get_c(cls) << endl;
    cout << get_d(cls) << endl;
    cout << get_i(cls) << endl;

    // запись
    get_c(cls) = 'b';                   // непривычно так присваивать, а оказывается можно...
    cout << get_c(cls) << endl;

    /* через приведение типов в стиле C++ reinterpret_cast */
    cout << "Cpp-style:" << endl;
    // чтение
    cout << get_c_(cls) << endl;
    cout << get_d_(cls) << endl;
    cout << get_i_(cls) << endl;

    // запись
    get_c(cls) = 'h';                   // непривычно так присваивать, а оказывается можно...
    cout << get_c_(cls) << endl;



    return 0;
}